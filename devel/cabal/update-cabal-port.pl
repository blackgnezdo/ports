#!/usr/bin/perl
#
# Update a cabal port to a new version
#
# Usage: update-cabal-port.pl <port-directory> [options]
#
# Options:
#   --version <ver>    Update to specific version (default: latest from Hackage)
#   --dry-run          Show what would be done without making changes
#   --no-makesum       Skip running 'make makesum'
#   --package          Run 'make package' after update
#   --help             Show this help message
#

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use File::Basename;
use Cwd qw(abs_path getcwd);

sub usage {
    my $exit_code = shift // 0;
    open my $fh, '<', $0 or die "Cannot read $0: $!\n";
    while (<$fh>) {
        last if /^$/;
        next unless s/^# ?//;
        print;
    }
    close $fh;
    exit $exit_code;
}

# Parse command line options
my %opt = (
    version => '',
    dry_run => 0,
    makesum => 1,
    package => 0,
    help => 0,
);

GetOptions(
    'version=s' => \$opt{version},
    'dry-run' => \$opt{dry_run},
    'no-makesum' => sub { $opt{makesum} = 0 },
    'package' => \$opt{package},
    'help|h' => \$opt{help},
) or usage(1);

usage(0) if $opt{help};

my $port_dir = shift @ARGV or do {
    print STDERR "Error: Port directory required\n";
    usage(1);
};

die "Error: Directory $port_dir does not exist\n" unless -d $port_dir;
die "Error: No Makefile found in $port_dir\n" unless -f "$port_dir/Makefile";

chdir $port_dir or die "Cannot chdir to $port_dir: $!\n";
my $port_name = basename(getcwd());
my $category = basename(dirname(getcwd()));
my $full_name = "$category/$port_name";

print "==> Updating cabal port: $full_name\n\n";

# Extract current configuration from Makefile
print "==> Extracting current configuration...\n";

my %config;
open my $makefile, '<', 'Makefile' or die "Cannot open Makefile: $!\n";
while (<$makefile>) {
    if (/^MODCABAL_STEM\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{stem} = trim($1);
    } elsif (/^MODCABAL_VERSION\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{version} = trim($1);
    } elsif (/^MODCABAL_FLAGS\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{flags} = trim($1);
    } elsif (/^MODCABAL_EXECUTABLES\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{executables} = trim($1);
    } elsif (/^MODCABAL_BUILD_ARGS\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{build_args} = trim($1);
    } elsif (/^MODCABAL_DATA_DIR\s*=\s*(.+?)(?:\s*#.*)?$/) {
        $config{data_dir} = trim($1);
    }
}
close $makefile;

die "Error: Could not determine MODCABAL_STEM from Makefile\n" unless $config{stem};

# Extract cabal-bundler command from existing manifest or Makefile comments
my $bundler_cmd = '';
if (-f 'cabal-manifest.inc') {
    open my $inc, '<', 'cabal-manifest.inc' or die "Cannot open cabal-manifest.inc: $!\n";
    my $first_line = <$inc>;
    if ($first_line && $first_line =~ /^# Generated by: (.+)$/) {
        $bundler_cmd = $1;
    }
    close $inc;
}

unless ($bundler_cmd) {
    open my $mf, '<', 'Makefile' or die "Cannot open Makefile: $!\n";
    while (<$mf>) {
        if (/^\s*#\s*cabal-bundler\s+(.+)$/) {
            $bundler_cmd = trim($1);
            last;
        }
    }
    close $mf;
}

print "  Package:         $config{stem}\n";
print "  Current version: $config{version}\n" if $config{version};
print "  Flags:           $config{flags}\n" if $config{flags};
print "  Executables:     $config{executables}\n" if $config{executables};
print "  Build args:      $config{build_args}\n" if $config{build_args};
print "  Data dir:        $config{data_dir}\n" if $config{data_dir};
print "  Bundler command: $bundler_cmd\n" if $bundler_cmd;
print "\n";

# Determine target version
my $target_version = $opt{version};

unless ($target_version) {
    print "==> Fetching latest version from Hackage...\n";
    $target_version = get_latest_hackage_version($config{stem});

    unless ($target_version) {
        die "Error: Could not determine latest version from Hackage\n" .
            "Please specify version with --version\n";
    }

    print "  Latest version: $target_version\n";
} else {
    print "  Target version: $target_version (specified)\n";
}
print "\n";

# Check if already at target version
if ($config{version} && $config{version} eq $target_version) {
    print "==> Already at version $target_version, nothing to do\n";
    exit 0;
}

# Construct cabal-bundler command
print "==> Constructing cabal-bundler command...\n";

my @bundler_args = ('--openbsd', "$config{stem}-$target_version");

# Add flags if present
if ($config{flags}) {
    push @bundler_args, '--flags', qq{"$config{flags}"};
}

# Add executables if specified and different from stem
if ($config{executables}) {
    my $exec = $config{executables};
    # Remove variable references like ${MODCABAL_STEM}
    $exec =~ s/\$\{[^}]+\}//g;
    $exec = trim($exec);

    if ($exec && $exec ne $config{stem}) {
        for my $exe (split /\s+/, $exec) {
            push @bundler_args, '--executable', $exe;
        }
    }
}

my $bundler_cmd_str = 'cabal-bundler ' . join(' ', @bundler_args);
print "  Command: $bundler_cmd_str\n";

# Note if special configuration is present
if ($config{build_args}) {
    print "\n  NOTE: This port uses MODCABAL_BUILD_ARGS=$config{build_args}\n";
    print "  This may require special attention after the update.\n";
}

print "\n";

if ($opt{dry_run}) {
    print "==> DRY RUN: Would execute the following steps:\n";
    print "  1. Run: $bundler_cmd_str\n";
    print "  2. Generate new cabal-manifest.inc\n";
    print "  3. Update MODCABAL_VERSION to $target_version in Makefile\n";
    print "  4. Run: make makesum\n" if $opt{makesum};
    print "  5. Run: make package\n" if $opt{package};
    exit 0;
}

# Run cabal-bundler
print "==> Running cabal-bundler...\n";

my $output = run_command(@bundler_args);
unless ($output =~ /^MODCABAL_MANIFEST/m) {
    die "Error: cabal-bundler output doesn't contain MODCABAL_MANIFEST\n$output\n";
}

print "  cabal-bundler completed successfully\n";

# Extract manifest from output
my @manifest_lines;
my $in_manifest = 0;
for my $line (split /\n/, $output) {
    if ($line =~ /^MODCABAL_MANIFEST\s*=\s*(.*)/) {
        $in_manifest = 1;
        my $data = $1;
        $data =~ s/\s*\\$//;
        push @manifest_lines, split(/\s+/, $data) if $data =~ /\S/;
    } elsif ($in_manifest) {
        if ($line =~ /^\s+(.*)/) {
            my $data = $1;
            $data =~ s/\s*\\$//;
            push @manifest_lines, split(/\s+/, $data) if $data =~ /\S/;
            $in_manifest = 0 unless $line =~ /\\$/;
        } else {
            $in_manifest = 0;
        }
    }
}

# Generate new cabal-manifest.inc
print "==> Generating cabal-manifest.inc...\n";

open my $inc_out, '>', 'cabal-manifest.inc' or die "Cannot write cabal-manifest.inc: $!\n";
print $inc_out "# Generated by: $bundler_cmd_str\n\n";

# Process manifest lines in triples
my $dep_count = 0;
while (@manifest_lines >= 3) {
    my ($pkg, $ver, $rev) = splice(@manifest_lines, 0, 3);
    print $inc_out "MODCABAL_MANIFEST += $pkg $ver $rev\n";
    $dep_count++;
}

close $inc_out;

print "  Generated cabal-manifest.inc with $dep_count dependencies\n";

# Update MODCABAL_VERSION in Makefile
print "==> Updating MODCABAL_VERSION in Makefile...\n";

# Read entire Makefile
open my $mf_in, '<', 'Makefile' or die "Cannot open Makefile: $!\n";
my @makefile_lines = <$mf_in>;
close $mf_in;

# Backup
system('cp', 'Makefile', 'Makefile.update-backup') == 0
    or die "Failed to backup Makefile: $!\n";

# Update version
my $updated = 0;
for my $line (@makefile_lines) {
    if ($line =~ /^MODCABAL_VERSION\s*=/) {
        $line = "MODCABAL_VERSION =\t$target_version\n";
        $updated = 1;
    }
}

die "Error: MODCABAL_VERSION not found in Makefile\n" unless $updated;

# Write back
open my $mf_out, '>', 'Makefile' or die "Cannot write Makefile: $!\n";
print $mf_out @makefile_lines;
close $mf_out;

print "  Updated MODCABAL_VERSION: $config{version} -> $target_version\n";

# Ensure Makefile includes cabal-manifest.inc
my $has_include = 0;
for my $line (@makefile_lines) {
    if ($line =~ /cabal-manifest\.inc/) {
        $has_include = 1;
        last;
    }
}

unless ($has_include) {
    print "  Warning: Makefile doesn't include cabal-manifest.inc\n";
    print "  You may need to migrate the port first using migrate-to-inc.sh\n";
}

# Run make makesum
if ($opt{makesum}) {
    print "\n==> Running make makesum...\n";
    if (system('make', 'makesum') == 0) {
        print "  Checksums updated successfully\n";
        unlink 'Makefile.update-backup';
    } else {
        print STDERR "Error: make makesum failed\n";
        print STDERR "Rolling back changes...\n";
        rename 'Makefile.update-backup', 'Makefile';
        exit 1;
    }
}

# Run make package
if ($opt{package}) {
    print "\n==> Running make package...\n";
    if (system('make', 'package') == 0) {
        print "  Package built successfully\n";
    } else {
        print STDERR "Warning: make package failed\n";
        print STDERR "You may need to:\n";
        print STDERR "  - Update patches manually\n";
        print STDERR "  - Fix PLIST issues\n";
        print STDERR "  - Adjust build flags\n";
        if ($config{build_args}) {
            print STDERR "  - Review MODCABAL_BUILD_ARGS=$config{build_args}\n";
        }
        exit 1;
    }
}

print "\n==> Update complete!\n";
print "  Port:        $full_name\n";
print "  Old version: $config{version}\n" if $config{version};
print "  New version: $target_version\n";
print "  Dependencies: $dep_count\n";

if ($config{build_args}) {
    print "\n  NOTE: This port uses MODCABAL_BUILD_ARGS\n";
    print "  Review if these arguments are still appropriate for the new version.\n";
}

print "\nNext steps:\n";
print "  1. Review changes: git diff\n";
print "  2. Test build:     make package\n" unless $opt{package};
print "  3. Test install:   make install\n";
print "  4. Run tests:      make test (if available)\n";

exit 0;

#
# Helper functions
#

sub trim {
    my $str = shift;
    $str =~ s/^\s+|\s+$//g;
    return $str;
}

sub get_latest_hackage_version {
    my $package = shift;

    # Try preferred version API first
    my $url = "https://hackage.haskell.org/package/$package/preferred";
    my $json = fetch_url($url);

    if ($json) {
        # Simple JSON parsing for "normal-version" field
        if ($json =~ /"normal-version"\s*:\s*"([^"]+)"/) {
            return $1;
        }
    }

    # Fallback: try to scrape package page
    $url = "https://hackage.haskell.org/package/$package";
    my $html = fetch_url($url);

    if ($html && $html =~ /$package-([0-9][0-9.]*)/) {
        return $1;
    }

    return '';
}

sub fetch_url {
    my $url = shift;

    # Try curl first
    if (system('which', 'curl') == 0) {
        my $content = `curl -sS '$url' 2>/dev/null`;
        return $content if $? == 0;
    }

    # Try ftp (OpenBSD's ftp can fetch HTTP)
    if (system('which', 'ftp') == 0) {
        my $content = `ftp -o - '$url' 2>/dev/null`;
        return $content if $? == 0;
    }

    return '';
}

sub run_command {
    my @args = @_;
    my $cmd = 'cabal-bundler ' . join(' ', map { shell_quote($_) } @args);

    my $output = `$cmd 2>&1`;
    if ($? != 0) {
        die "Error: cabal-bundler failed\n$output\n";
    }

    return $output;
}

sub shell_quote {
    my $str = shift;
    return $str unless $str =~ /[\s'"]/;
    $str =~ s/'/'\\''/g;
    return "'$str'";
}
